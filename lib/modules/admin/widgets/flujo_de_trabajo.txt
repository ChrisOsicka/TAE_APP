
Flujo completo de AdaptiveBranchList, BranchListView y BranchCard

AdaptiveBranchList
üîπ Mide pantalla ‚Üí decide ancho de tarjetas ‚Üí llama a BranchListView.

BranchListView
üîπ Recorre la lista de sucursales ‚Üí crea una tarjeta por cada sucursal ‚Üí llama a BranchCard.

BranchCard
üîπ Dibuja el dise√±o de la tarjeta individual con textos e √≠cono ‚Üí maneja la navegaci√≥n al detalle.

üí° Met√°fora:

AdaptiveBranchList ‚Üí El arquitecto que decide cu√°nto espacio usar.

BranchListView ‚Üí El encargado de producci√≥n que organiza todas las tarjetas en fila.

BranchCard ‚Üí El dise√±ador que hace bonita cada tarjeta y le da interacci√≥n.


==>  ¬øPor qu√© es necesario pasarlo en cada clase?

üîπ 1. Widgets en Flutter son inmutables

Cada widget es una descripci√≥n de la UI. No guarda datos ‚Äúvivos‚Äù, sino que recibe par√°metros (propiedades) que describen c√≥mo debe pintarse.
Por eso, si un widget hijo necesita mostrar algo (un texto, un √≠cono, un color, etc.), ese dato debe llegarle como par√°metro.

üîπ 2. Ejemplo con tu caso

Tienes dos clases:

=> BranchListView

    Se encarga de mostrar una lista de sucursales (branches).
    Dentro de cada elemento, necesita un BranchCard para mostrar los datos de esa sucursal.
    Como cada BranchCard debe mostrar tambi√©n un √≠cono, BranchListView recibe el icon y se lo pasa al BranchCard.

BranchCard(
  branch: branch,
  maxCardWidth: maxCardWidth,
  icon: icon, // <- se lo pasa para que lo use
);

=> BranchCard

Es la tarjeta individual de una sucursal.
No sabe nada de la lista, solo c√≥mo dibujar una sucursal.
Para poder dibujar el √≠cono, necesita que alguien se lo proporcione (por eso recibe icon en su constructor).

üîπ 3. ¬øPor qu√© no basta con declararlo en una sola clase?

Imagina que el icon lo declaras solo en BranchListView.
¬øC√≥mo lo sabr√≠a el BranchCard si nunca se lo pasas? ü§î
El BranchCard no tiene acceso directo a las variables del padre, porque en Flutter cada widget es independiente y aislado.

Entonces, para que el dato viaje, debes pasarlo expl√≠citamente:
    Parent (BranchListView) ‚Üí Child (BranchCard)

üîπ 4. Regla general

    > Si un dato lo necesita un solo widget, d√©jalo dentro de ese widget.
    > Si lo necesitan varios hijos, s√∫belo al padre y p√°salo como par√°metro a cada hijo.
    > Si lo necesitan muchos widgets en distintas partes de la app, ah√≠ conviene usar 
    un manejador de estado (Provider, Riverpod, Bloc, etc.) para no estar pasando par√°metros a mano en cada nivel.

üëâ Entonces, respondiendo a tu duda:
Es necesario pasarlo en cada clase porque cada widget es independiente y solo sabe lo que recibe en su constructor. 
Si un hijo necesita un valor, se lo tienes que dar expl√≠citamente, salvo que uses un gestor de estado global.